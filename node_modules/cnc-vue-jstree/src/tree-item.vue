<template>
  <li role="treeitem"
      :class="classes"
      :draggable="draggable && !isEdited"
      @dragstart.stop="onItemDragStart($event, _self, _self.model)"
      @dragend.stop.prevent="onThisItemDragEnd($event, _self, _self.model)"
      @dragover.stop.prevent="onItemDragOver($event, _self, _self.model)"
      @dragenter.stop.prevent="onDragState(true)"
      @dragleave.stop.prevent="onDragState(false)"
      @drop.stop.prevent="handleItemDrop($event, _self, _self.model)">
    <div role="presentation" :class="wholeRowClasses" v-if="isWholeRow">&nbsp;</div>
    <div :class="dropCss"></div>
    <i class="tree-icon tree-ocl" role="presentation" @click="handleItemToggle"></i>
    <div
        :class="anchorClasses"
        @dblclick.stop="editItem(model)"
        @click="handleItemClick"
        @mouseover.stop="isHover = true"
        @mouseout.stop="isHover = false">
      <i class="tree-icon tree-checkbox"
          role="presentation" @click.stop="handleItemCheckbox"
          v-if="showCheckbox && !model.loading"></i>
      <i :class="themeIconClasses" role="presentation" v-if="!model.loading"></i>
      <slot name="itemTxt" v-if="!model.edited"
          :vm="this"
          :item="item"
          :children="model.children"
          :selected="model.selected"
          :opened="model.opened">
        {{ itemText }}
      </slot>
      <input v-focus v-if="isEdited" v-model="newText" v-on:blur.stop="editSave(model)" @keyup.enter.stop="editSave(model)" @keyup.esc.stop="editCancel(model)">
      <slot name="itemActions" :item="item" :vm="this"></slot>
    </div>

    <ul role="group" ref="group" class="tree-children" v-if="isFolder" v-show="model.opened">
      <tree-item v-for="(child, index) in model.children"
          :key="index"
          :item="child"
          :text-field-name="textFieldName"
          :id-field-name="idFieldName"
          :parent-field-name="parentFieldName"
          :whole-row="wholeRow"
          :show-checkbox="showCheckbox"
          :height= "height"
          :parent-id="model[idFieldName]"
          :parent-order="model.order"
          :parent-item="model.children"
          :draggable="draggable"
          :on-item-click="onItemClick"
          :on-item-toggle="onItemToggle"
          :on-item-drag-start="onItemDragStart"
          :on-item-drag-end="onItemDragEnd"
          :allowed-to-drop="allowedToDrop"
          :on-item-drop="onItemDrop"
          :on-text-changed="onTextChanged"
          :on-delete-item="onDeleteItem"
          :set-draggable="setDraggable"
          :add-new-child="addNewChild"
          :get-id-val="getIdVal"
          :klass="index === model.children.length-1?'tree-last':''">
          <template slot="itemTxt" slot-scope="_">
            <slot name="itemTxt" :vm="_.vm"
                :parentId="_.parentId"
                :item="_.item"
                :children="_.children"
                :selected="_.selected"
                :draggable="_.draggable"
                :opened="_.opened">
            </slot>
          </template>
          <template slot="itemActions" slot-scope="_">
            <slot name="itemActions" :item="_.item" :vm="_.vm"></slot>
          </template>
      </tree-item>
    </ul>
  </li>
</template>

<script>
  const DropPosition = {
    empty: '0',
    up: '1',
    inside: '2',
    down: '3'
  }
  export default {
    name: 'TreeItem',
    props: {
      item: {type: Object, required: true},
      textFieldName: {type: String, default: 'text'},
      idFieldName: {type: String, default: 'id'},
      parentFieldName: {type: String, default: 'parent'},
      wholeRow: {type: Boolean, default: false},
      showCheckbox: {type: Boolean, default: false},
      height: {type: Number, default: 24},
      parentId: {type: String, default: ''},
      parentOrder: {type: String, default: ''},
      parentItem: {type: Array},
      draggable: {type: Boolean, default: false},
      onItemClick: {
        type: Function, default: () => false
      },
      onItemToggle: {
        type: Function, default: () => false
      },
      onItemDragStart: {
        type: Function, default: () => false
      },
      onItemDragEnd: {
        type: Function, default: () => false
      },
      allowedToDrop: {
        type: Function, default: () => true
      },
      onItemDrop: {
        type: Function, default: () => false
      },
      onTextChanged: {
        type: Function, default: () => ''
      },
      onDeleteItem: {
        type: Function, default: () => ''
      },
      setDraggable: {
        type: Function, default: () => false
      },
      addNewChild: {
        type: Function, default: () => ''
      },
      getIdVal: {
        type: Function, default: () => ''
      },
      klass: String
    },
    data () {
      return {
        isHover: false,
        isDragEnter: false,
        myParentId: '',
        model: this.item,
        dropPosition: '0',
        dropCss: '',
        newText: ''
      }
    },
    watch: {
      // isDragEnter (newValue) {
      //   // console.log(newValue)
      //   if (newValue) {
      //     this.$el.style.backgroundColor = '#C9FDC9'
      //   } else {
      //     this.$el.style.backgroundColor = 'inherit'
      //     this.dropCss = ''
      //   }
      // },
      item (newValue) {
        this.model = newValue
      }
    },
    computed: {
      itemText () {
        return this.model[this.textFieldName]
      },
      isFolder () {
        return this.model.children && this.model.children.length
      },
      isEdited () {
        if (this.model[this.textFieldName] && this.model[this.textFieldName] !== '') this.newText = this.model[this.textFieldName]
        return this.model.edited
      },
      classes () {
        return [
          {'tree-node': true},
          {'tree-open': this.model.opened},
          {'tree-closed': !this.model.opened},
          {'tree-leaf': !this.isFolder},
          {'tree-loading': !!this.model.loading},
          {'tree-drag-enter': this.isDragEnter},
          {[this.klass]: !!this.klass}
          // this.onItemDropCss(this.isDragEnter)
        ]
      },
      anchorClasses () {
        return [
          {'tree-anchor': true},
          {'tree-disabled': this.model.disabled},
          {'tree-selected': this.model.selected},
          {'tree-hovered': this.isHover}
        ]
      },
      wholeRowClasses () {
        return [
          {'tree-wholerow': true},
          {'tree-wholerow-clicked': this.model.selected},
          {'tree-wholerow-hovered': this.isHover}
        ]
      },
      themeIconClasses () {
        return [
          {'tree-icon': !this.model.icon},
          // {'tree-themeicon': true},
          {'tree-icon-folder': (!this.model.icon && (this.model.children.length > 0 || this.model.canDrop))},
          {'tree-icon-file': (!this.model.icon && this.model.children.length === 0 && !this.model.canDrop)},
          {'tree-icon-prep': !!this.model.icon},
          {[this.model.icon]: !!this.model.icon}
        ]
      },
      isWholeRow () {
        if (this.wholeRow) {
          if (this.$parent.model === undefined) {
            return true
          } else if (this.$parent.model.opened === true) {
            return true
          } else {
            return false
          }
        }
      }
    },
    methods: {

      onThisItemDragEnd (e, _self, model) {
        this.dropPosition = '0'
        this.dropCss = ''
        this.onItemDragEnd(e, _self, model)
      },
      onDragState (entered) {
        if (entered) {
          this.$el.style.backgroundColor = '#C9FDC9'
          this.isDragEnter = true
        } else {
          this.$el.style.backgroundColor = 'inherit'
          this.isDragEnter = false
          this.dropPosition = '0'
          this.dropCss = ''
        }
      },
      onItemDragOver (e, oriNode, oriItem) {
        if (!oriItem.edited) {
          const oriPoz = oriNode.$el.getBoundingClientRect()
          const position = this.getDropPosition(e.clientY, oriPoz.top, 24).toString()
          if (this.dropPosition !== position) {
            this.dropPosition = position
            var dropCss = 'tree-marker-' + position
            if (!this.allowedToDrop(oriItem, position)) dropCss += ' not-allowed'
            this.dropCss = dropCss
            // return this.isDragEnter ? allowed + ' tree-marker-' + position : ''
          } else {
            // if (!this.isDragEnter) this.dropCss = ''
          }
        }
      },
      editItem (item) {
        this.setDraggable(false)
        item.edited = true
        this.newText = item[this.textFieldName]
      },
      editCancel (item) {
        if (this.newText === '') {
          const index = this.parentItem.indexOf(item)
          this.parentItem.splice(index, 1)
        }
        this.setDraggable()
        item.edited = false
        this.newText = item[this.textFieldName]
      },
      editSave (item) {
        // console.log('editSave', this.newText)
        if (item.edited) {
          if (this.newText === '') {
            const index = this.parentItem.indexOf(item)
            // console.log('Empty text, cancel save and remove')
            this.parentItem.splice(index, 1)
          } else {
            this.onTextChanged(item, this.newText)
          }
          this.newText = ''
          item.edited = false
          this.setDraggable()
        }
      },
      addSubItem () {
        var newItem = this.addNewChild(this, this.model, '2')
        if (newItem) {
          this.setDraggable(false)
          if (newItem[this.textFieldName] && newItem[this.textFieldName] !== '') this.newText = newItem[this.textFieldName]
          this.model.children.push(newItem)
          this.model.opened = true
        }
      },
      addNextItem () {
        var newItem = this.addNewChild(this, this.model, '3')
        if (newItem) {
          this.setDraggable(false)
          var oriIndex = this.parentItem.indexOf(this.model)
          this.parentItem.splice(oriIndex + 1, 0, newItem)
        }
      },
      deleteItem (item) {
        // console.log('DELETE', item)
        var self = this
        this.onDeleteItem(item, function (item) {
          // console.log('Done DELETE', item)
          var oriIndex = self.parentItem.indexOf(item)
          if (oriIndex !== -1) self.parentItem.splice(oriIndex, 1)
        })
      },
      getDropPosition (pageY, offsetTop, offsetHeight) {
        // 340 - 326 = top = 14. height = 24
        const top = pageY - offsetTop
        if (this.model.canDrop) {
          if (top < offsetHeight / 3) {
            return DropPosition.up
          } else if (top > offsetHeight * 2 / 3) {
            return DropPosition.down
          } else {
            return DropPosition.inside
          }
        } else {
          if (top < offsetHeight / 2) {
            return DropPosition.up
          } else {
            return DropPosition.down
          }
        }
      },
      handleRecursionNodeParents (node, func) {
        if (node.$parent) {
          func(node.$parent)
          this.handleRecursionNodeParents(node.$parent, func)
        }
      },
      handleItemToggle () {
        if (this.isFolder) {
          this.model.opened = !this.model.opened
          this.onItemToggle(this, this.model)
          // this.handleSetGroupMaxHeight()
        }
      },
      handleGroupMaxHeight () {
        let length = 0
        let childHeight = 0
        if (this.model.opened) {
          length = this.$children.length
          for (let children of this.$children) {
            childHeight += children.handleGroupMaxHeight()
          }
        }
        return length * this.height + childHeight
      },
      handleSetGroupMaxHeight () {
        if (this.$refs.group) {
          this.$refs.group.style.maxHeight = this.handleGroupMaxHeight() + 'px'
        }
        var self = this
        this.$nextTick(() => {
          this.handleRecursionNodeParents(self, node => {
            if (node.$refs.group) {
              node.$refs.group.style.maxHeight = node.handleGroupMaxHeight() + 'px'
            }
          })
        })
      },
      handleItemCheckbox () {
        if (this.model.disabled) return
        this.model = this.onItemClick(this, this.model, true)
      },
      handleItemClick () {
        if (this.model.disabled) return
        // this.model.selected = !this.model.selected
        this.model = this.onItemClick(this, this.model, false)
      },
      handleItemDblClick () {
        this.model.edited = true
        this.newText = this.model[this.textFieldName]
      },
      handleItemDrop (e, oriNode, oriItem) {
        this.$el.style.backgroundColor = 'inherit'
        this.onItemDrop(e, oriNode, oriItem, this.dropPosition)
        this.dropPosition = '0'
        this.dropCss = ''
      }
    },
    mounted () {
      this.myParentId = this.getIdVal(this.model)
      // this.handleSetGroupMaxHeight()
    }
  }
</script>