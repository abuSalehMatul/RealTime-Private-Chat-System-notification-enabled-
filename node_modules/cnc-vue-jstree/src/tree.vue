<template>
  <div :class="classes" role="tree" onselectstart="return false" @dblclick="addLastItem()">
    <ul :class="containerClasses" role="group">
      <tree-item v-for="(child, index) in dataTree"
          :key="index"
          :item="child"
          :text-field-name="textFieldName"
          :id-field-name="idFieldName"
          :parent-field-name="parentFieldName"
          :whole-row="wholeRow"
          :show-checkbox="showCheckbox"
          :height="sizeHight"
          :parent-id="child[parentFieldName]"
          :parent-order="'!!'"
          :parent-item="dataTree"
          :draggable="itemDraggable"
          :on-item-click="onItemClick"
          :on-item-toggle="onItemToggle"
          :on-item-drag-start="onItemDragStart"
          :on-item-drag-end="onItemDragEnd"
          :allowed-to-drop="allowedToDrop"
          :on-item-drop="onItemDrop"
          :on-text-changed="onTextChanged"
          :on-delete-item="onDeleteItem"
          :set-draggable="setDraggable"
          :add-new-child="addNewChild"
          :get-id-val="getIdVal"
          :klass="index === dataTree.length-1?'tree-last':''">
        <template slot="itemTxt" slot-scope="_">
          <slot name="itemTxt" :vm="_.vm"
              :item="_.item"
              :children="_.children"
              :selected="_.selected"
              :opened="_.opened">
            <i :class="_.themeIconClasses" role="presentation" ></i>
            <div class='treeitem-text'>{{ _.item.title }}</div>
          </slot>
        </template>
        <template slot="itemActions" slot-scope="_">
          <slot name="itemActions" :item="_.item" :vm="_.vm"></slot>
        </template>
      </tree-item>
    </ul>
    <!-- data <textarea style="height:200px; width:50%;">{{data}}</textarea>
    <br/>
    <br/>
    mapCollapsed <textarea style="height:200px; width:50%;">{{mapCollapsed}}</textarea> -->
  </div>
</template>
<script>
  import TreeItem from './tree-item.vue'
  import _ from 'lodash'
  import Vue from 'vue'
  Vue.directive('focus', {
    // When the bound element is inserted into the DOM...
    inserted: function (el) {
      // Focus the element
      el.focus()
    }
  })

  let ITEM_HEIGHT_SMALL = 18
  let ITEM_HEIGHT_DEFAULT = 24
  let ITEM_HEIGHT_LARGE = 32

  export default {
    name: 'cncVueJstree',
    props: {
      settings: {type: Object},
      data: {type: Array},
      dataIsFlat: {type: Boolean, default: false},
      size: {type: String, validator: value => ['large', 'small'].indexOf(value) > -1},
      showCheckbox: {type: Boolean, default: false},
      selectOnClick: {type: Boolean, default: false},
      wholeRow: {type: Boolean, default: false},
      noDots: {type: Boolean, default: false},
      multiple: {type: Boolean, default: false},
      allowBatch: {type: Boolean, default: false},
      textFieldName: {type: String, default: 'text'},
      orderFieldName: {type: String, default: ''},
      idFieldName: {type: String, default: 'id'},
      parentFieldName: {type: String, default: 'parent'},
      async: {type: Function},
      canDrop: {type: Function, default: () => true},
      onNewItemBefore: {type: Function},
      onNewItemAfter: {type: Function},
      onDeleteItem: {type: Function},
      loadingText: {type: String, default: 'Loading...'},
      draggable: {type: Boolean, default: false},
      klass: String
    },
    data () {
      return {
        loadDataOnWatch: true,
        dataTree: [],
        mapCollapsed: {},
        selectedItem: null,
        draggedItem: null,
        itemDraggable: false,
        orderChars: [34, 34]
      }
    },
    computed: {
      classes () {
        return [
          {'tree': true},
          {'tree-default': !this.size},
          {[`tree-default-${this.size}`]: !!this.size},
          {'tree-checkbox-selection': !!this.showCheckbox},
          {[this.klass]: !!this.klass}
        ]
      },
      containerClasses () {
        return [
          {'tree-container-ul': true},
          {'tree-children': true},
          {'tree-wholerow-ul': !!this.wholeRow},
          {'tree-no-dots': !!this.noDots}
        ]
      },
      sizeHight () {
        switch (this.size) {
          case 'large':
            return ITEM_HEIGHT_LARGE
          case 'small':
            return ITEM_HEIGHT_SMALL
          default:
            return ITEM_HEIGHT_DEFAULT
        }
      }
    },
    methods: {

      getIdVal (item) {
        return item[this.idFieldName] || item.id || item.uid || ''
      },
      initializeSettings (objset) {
        /* Vue2 is not recomending changing props directly.
        ** Need rewrite to define data values and use settings or props to define data values */
        for (var key in objset) {
          // skip loop if the property is from prototype
          if (!objset.hasOwnProperty(key)) continue
          this[key] = objset[key]
        }
      },
      initializeFlatData (items) {
        var tree = []
        // _.forOwn(new Foo, function(value, key) {
        //   console.log(key);
        // });
        var map = {}
        for (var i = 0; i < items.length; i++) {
          var Id = items[i][this.idFieldName] || items[i].id || items[i].uid || items[i].model
          if (!(Id in this.mapCollapsed)) this.mapCollapsed[Id] = {}
          if (!(Id in map)) {
            map[Id] = _.merge({}, this.initializeDataItem(items[i], true), this.mapCollapsed[Id])
            // map[Id] = this.initializeDataItem(items[i])
            // Build object to preserv item status in case of data beeing loaded
            // this.mapCollapsed[Id] = {
            //   opened: map[Id].opened,
            //   selected: map[Id].selected
            // }
          } else {
            map[Id] = _.merge({}, map[Id], this.initializeDataItem(items[i], true), this.mapCollapsed[Id])
          }
          // map[Id].item = items[i]
          if (!this.mapCollapsed[Id][this.orderFieldName]) this.mapCollapsed[Id][this.orderFieldName] = map[Id][this.orderFieldName]

          // Handle case when parent is defined
          // if (typeof items[i][this.parentFieldName] !== 'undefined' && items[i][this.parentFieldName] !== '') {
          // var pId = items[i][this.parentFieldName]
          var pId = _.get(items[i], this.parentFieldName)
          if (typeof pId !== 'undefined' && pId !== '' && pId !== null) {
            map[Id][this.parentFieldName] = pId
            // Create parent if not previously created and add children
            if (!(pId in map)) map[pId] = {}
            if (typeof map[pId].children === 'undefined') map[pId].children = []
            map[pId].children.push(map[Id])
          } else {
            tree.push(map[Id])
          }
        }
        // Define Root node
        this.dataTree = tree
      },
      initializeData (items) {
        if (items && items.length > 0) {
          for (let i in items) {
            var dataItem = this.initializeDataItem(items[i])
            items[i] = dataItem
            this.initializeData(items[i].children)
          }
        }
      },
      initializeDataItem (rawItem, createItem = true) {
        let model = {
          children: rawItem.children || [],
          [this.idFieldName]: rawItem[this.idFieldName] || rawItem.id || rawItem.uid || '',
          // item: rawItem || {},
          canDrop: rawItem.canDrop || this.canDrop(rawItem),
          icon: rawItem.icon || '',
          edited: rawItem.edited || false,
          opened: rawItem.opened || false,
          selected: rawItem.selected || false,
          disabled: rawItem.disabled || false,
          loading: rawItem.loading || false
        }
        if (createItem) model.obj = rawItem || {}
        if (this.orderFieldName !== '') model[this.orderFieldName] = rawItem[this.orderFieldName] || this.getOrderNextVal()
        model[this.textFieldName] = rawItem[this.textFieldName] || ''
        return model
      },
      initializeLoading () {
        var item = {}
        item[this.textFieldName] = this.loadingText
        item.disabled = true
        item.loading = true
        return this.initializeDataItem(item)
      },
      handleRecursionNodeChilds (node, func) {
        if (node.children && node.children.length > 0) {
          for (let childNode of node.children) {
            if (!childNode.disabled) {
              func(childNode)
              this.handleRecursionNodeChilds(childNode, func)
            }
          }
        }
      },
      onItemClick (oriNode, oriItem, onCheckbox) {
        if (oriItem.edited) {
          return oriItem
        } else {
          if (this.selectOnClick || onCheckbox) {
            this.$emit('item-select', oriNode, oriItem)
            oriItem.selected = !oriItem.selected
            if (oriItem[this.idFieldName] !== '') {
              this.mapCollapsed[oriItem[this.idFieldName]].selected = oriItem.selected
            }
            if (this.multiple) {
              if (this.allowBatch) {
                this.handleBatchSelectItems(oriNode, oriItem)
              }
            } else {
              this.handleSingleSelectItems(oriNode, oriItem)
            }
          }
          if (this.selectOnClick || !onCheckbox) this.$emit('item-click', oriNode, oriItem)
          return oriItem
        }
      },
      handleSingleSelectItems (oriNode, oriItem) {
        if (this.selectedItem && this.selectedItem !== oriItem) {
          this.selectedItem.selected = false
          this.mapCollapsed[this.selectedItem[this.idFieldName]].selected = false
        }
        this.handleRecursionNodeChilds(oriItem, node => {
          node.selected = false
        })
        this.selectedItem = oriItem
        // oriNode.model.selected = true
      },
      handleBatchSelectItems (oriNode, oriItem) {
        const allSelected = oriItem.selected
        this.handleRecursionNodeChilds(oriItem, node => {
          if (node.disabled) return
          node.selected = allSelected
        })
      },
      onItemToggle (oriNode, oriItem) {
        this.mapCollapsed[oriItem[this.idFieldName]].opened = oriNode.model.opened
        if (oriNode.model.opened) {
          this.handleAsyncLoad(oriNode.model.children, oriNode, oriItem)
        }
      },
      handleAsyncLoad (oriParent, oriNode, oriItem) {
        var self = this
        if (this.async) {
          if (oriParent[0].loading) {
            this.async(oriNode, (data) => {
              if (data.length > 0) {
                for (let i in data) {
                  data[i].children = [self.initializeLoading()]
                  var dataItem = self.initializeDataItem(data[i])
                  self.$set(oriParent, i, dataItem)
                }
              } else {
                oriNode.model.children = []
              }
            })
          }
        }
      },
      onItemDragStart (e, oriNode, oriItem) {
        if (!this.draggable || oriItem.edited) { return false }

        e.dataTransfer.effectAllowed = 'move'
        e.dataTransfer.setData('text', null)
        this.draggedItem = {
          item: oriItem,
          parentItem: oriNode.parentItem,
          index: oriNode.parentItem.indexOf(oriItem)
        }
      },
      onItemDragEnd (e, oriNode, oriItem) {
        if (!this.draggable || oriItem.edited) { return false }
        this.draggedItem = null
      },
      allowedToDrop (oriItem, position) {
        if (!this.draggable || !this.draggedItem) {
          return false
        }
        if (position === '2' && oriItem.canDrop === false) return false
        if (this.draggedItem.parentItem === oriItem.children ||
          this.draggedItem.item === oriItem ||
          // (oriItem.children && oriItem.children.indexOf(this.draggedItem.item) !== -1) ||
          (this.draggedItem.item.children && this.draggedItem.item.children.indexOf(oriItem) !== -1)) {
          return false
        }
        return true
      },
      onItemDrop (e, oriNode, oriItem, position) {
        if (!this.draggable) return false
        if (this.draggedItem && oriItem[this.idFieldName] !== this.draggedItem.item[this.idFieldName]) {
          var newOrder = this.getOrder(oriNode, oriItem, position)
          var newParent = ''
          if (position === '2') {
            /** Item is droped on the other item (folder) ****/
            if (!this.allowedToDrop(oriItem, position)) return
            oriItem.children = oriItem.children ? oriItem.children.concat(this.draggedItem.item) : [this.draggedItem.item]
            oriItem.opened = true
            newParent = oriItem[this.idFieldName]

            var self = Object.assign({}, this)
            this.$nextTick(() => {
              self.draggedItem.parentItem.splice(self.draggedItem.index, 1)
            })
          } else if (oriNode.parentItem) {
            /** Item is droped before or under existing item ****/
            this.draggedItem.parentItem.splice(this.draggedItem.index, 1)
            if (oriNode.parentId) newParent = oriNode.parentId
            // Find position of destination item in the parent group
            var oriIndex = oriNode.parentItem.indexOf(oriItem)

            if (position === '1') {
              oriNode.parentItem.splice(oriIndex, 0, this.draggedItem.item)
            } else if (position === '3') {
              oriNode.parentItem.splice(oriIndex + 1, 0, this.draggedItem.item)
              // Figure out position
              // if (oriIndex === oriNode.parentItem.length - 1) {
              //   // Droped at the end of the list. Get order based on existing last item
              //   oriNode.parentItem.push(this.draggedItem.item)
              // } else {
              //   // Droped on item between first and last. Use above and below item order to calculate new order
              //   oriNode.parentItem.splice(oriIndex + 1, 0, this.draggedItem.item)
              // }
            }
          }
          // If order is changed, update item
          var changeObj = {}
          if (this.orderFieldName !== '' && newOrder !== '') {
            // this.draggedItem.item[this.orderFieldName] = newOrder
            if (this.draggedItem.item[this.idFieldName]) this.mapCollapsed[this.draggedItem.item[this.idFieldName]][this.orderFieldName] = newOrder
            changeObj[this.orderFieldName] = newOrder
          }
          if (newParent !== '') {
            // this.draggedItem.item[this.parentFieldName] = newParent
            changeObj[this.parentFieldName] = newParent
          }
          this.$emit('item-drop', this.draggedItem.item, oriItem, changeObj)
          _.assign(this.draggedItem.item, changeObj)
          this.replaceDataItem(this.draggedItem.item, changeObj)
          // this.draggedItem.item = _.merge({}, this.draggedItem.item, changeObj)
          this.draggedItem.item.obj = _.merge({}, this.draggedItem.item.obj, changeObj)
        }
      },
      getOrder (oriNode, oriItem, position) {
        var newOrder = 'AA'
        if (this.orderFieldName !== '') {
          if (position === '2') {
            if (oriItem.children.length > 0) {
              var lastItem = oriItem.children[oriItem.children.length - 1]
              if (lastItem[this.orderFieldName]) {
                newOrder = this.getOrderNextVal(lastItem[this.orderFieldName])
              }
            } else {
              newOrder = this.getOrderNextVal()
            }
          } else if (oriNode && oriNode.parentItem) {
            // Find position of destination item in the parent group
            var oriIndex = oriNode.parentItem.indexOf(oriItem)

            if (position === '1') {
              // Figure out position
              if (oriIndex === 0) {
                // Droped on the top of the list. Get order based on existing first item
                newOrder = this.getOrderMidVal(null, oriItem[this.orderFieldName])
              } else {
                // Droped on item between first and last. Use above and below item order to calculate new order
                var itemAbove2 = oriNode.parentItem[oriIndex - 1]
                var itemBelow2 = oriNode.parentItem[oriIndex]
                newOrder = this.getOrderMidVal(itemAbove2[this.orderFieldName], itemBelow2[this.orderFieldName])
              }
            } else if (position === '3') {
              // Figure out position
              if (oriIndex === oriNode.parentItem.length - 1) {
                // Droped at the end of the list. Get order based on existing last item
                var endItem = oriNode.parentItem[oriNode.parentItem.length - 1]
                if (endItem[this.orderFieldName]) {
                  newOrder = this.getOrderNextVal(endItem[this.orderFieldName])
                }
              } else {
                // Droped on item between first and last. Use above and below item order to calculate new order
                var itemAbove = oriNode.parentItem[oriIndex]
                var itemBelow = oriNode.parentItem[oriIndex + 1]
                newOrder = this.getOrderMidVal(itemAbove[this.orderFieldName], itemBelow[this.orderFieldName])
              }
            }
          } else if (oriItem) {
            newOrder = this.getOrderNextVal(null, oriItem[this.orderFieldName])
          }
        }
        return newOrder
      },
      addLastItem () {
        var newItem = this.addNewChild(null, null, 3)
        if (newItem) {
          this.dataTree.push(newItem)
          // this.model.opened = true
        }
      },
      // addNewChild (parentId) {
      addNewChild (oriNode, oriItem, position) {
        let parentId
        if (oriNode) {
          parentId = oriNode.myParentId
        }
        if (oriItem) {
          if (!oriItem.canDrop & position === '2') return null
          if (position === '3') parentId = oriItem[this.parentFieldName] || ''
        } else {
          if (this.data.length > 0) {
            oriItem = this.data[this.data.length - 1]
            if (position === '3') parentId = oriItem[this.parentFieldName] || ''
          }
        }
        let newOrder = this.getOrder(oriNode, oriItem, position)

        var newObj = {
          [this.parentFieldName]: parentId,
          [this.orderFieldName]: newOrder,
          [this.textFieldName]: ''
        }
        if (typeof this.onNewItemBefore !== 'undefined') newObj = this.onNewItemBefore(newObj)
        if (newObj) {
          if (!Object.isFrozen(this.data) && newObj.addToDataBefore && newObj[this.idFieldName] && newObj[this.idFieldName] !== '') {
            this.loadDataOnWatch = false
            delete newObj.addToDataBefore
            delete newObj.addToDataAfter
            this.data.push(newObj)
          }
          var newItem = this.initializeDataItem(newObj)
          newItem.edited = true
          // newItem.canDrop = true
          return newItem
        }
      },
      getOrderNextVal (startFrom) {
        if (startFrom) {
          let fromStr = startFrom.split('')
          let aChar = fromStr[0] ? fromStr[0].charCodeAt(0) : 34
          let bChar = fromStr[1] ? fromStr[1].charCodeAt(0) : 34
          if (aChar > this.orderChars[0]) this.orderChars[0] = aChar
          if (bChar > this.orderChars[1]) this.orderChars[1] = bChar
        }
        this.orderChars[0] = this.orderChars[0] + 1
        if (this.orderChars[0] === 126) {
          this.orderChars[1] = this.orderChars[1] + 1
          this.orderChars[0] = 34
        }
        return String.fromCharCode(this.orderChars[0]) + String.fromCharCode(this.orderChars[1])
      },
      getOrderMidVal (aWord, bWord) {
        if (aWord === null || aWord === '') aWord = '!!'
        let aChars = aWord.split('')
        let bChars = bWord.split('')
        var cWord = ''
        let charCount = aChars.length > bChars.length ? aChars.length : bChars.length
        for (var i = 0; i < charCount + 1; i++) {
          let aChar = aChars[i] ? aChars[i].charCodeAt(0) : 33
          let bChar = bChars[i] ? bChars[i].charCodeAt(0) : 126
          let cChar = Math.floor((aChar + bChar) / 2)
          cWord += String.fromCharCode(cChar)
          if (cChar !== aChar && cChar !== bChar) {
            i = charCount + 1
          }
        }
        return cWord
      },
      onTextChanged (item, newItemText) {
        var self = this
        if ((item[this.textFieldName] !== newItemText) || (item[this.textFieldName] === newItemText && item[this.idFieldName] === '')) {
          this.$emit('item-change', item, { [this.textFieldName]: newItemText })
          item[this.textFieldName] = newItemText
          // if this is not a new item, update existing
          if (item[this.idFieldName] && item[this.idFieldName] !== '') {
            this.replaceDataItem(item, { [this.textFieldName]: newItemText })
          } else {
            // Add to data array if requested and there is ID field defined. Othervise, let parent control to do it on emited event
            if (typeof this.onNewItemAfter !== 'undefined') {
              item[this.textFieldName] = newItemText
              this.onNewItemAfter(item, function (result) {
                // this.replaceDataItem(item, result)
                if (!Object.isFrozen(self.data) && !item.addToDataBefore && item.addToDataAfter && item[self.idFieldName] && item[self.idFieldName] !== '') {
                  delete item.addToDataBefore
                  delete item.addToDataAfter
                  self.loadDataOnWatch = false
                  self.data.push(item)
                }
              })
            } else {
              if (!Object.isFrozen(this.data) && !item.addToDataBefore && item.addToDataAfter && item[this.idFieldName] && item[this.idFieldName] !== '') {
                delete item.addToDataBefore
                delete item.addToDataAfter
                this.loadDataOnWatch = false
                this.data.push(item)
              }
            }
          }
        }
        item.edited = false
      },
      setDraggable (state) {
        if (typeof state !== 'undefined') {
          this.itemDraggable = state
        } else {
          this.itemDraggable = this.draggable
        }
      },
      replaceDataItem (item, replacement) {
        var id = item[this.idFieldName]
        var index = _.indexOf(this.data, _.find(this.data, { [this.idFieldName]: id }))
        if (!Object.isFrozen(this.data)) {
          this.loadDataOnWatch = false
          if (index !== -1) {
            this.data.splice(index, 1, _.merge({}, this.data[index], replacement))
          } else if (item.item) {
            delete item.item.addToDataBefore
            delete item.item.addToDataAfter
            var newItem = _.merge({}, item.item, replacement)
            this.data.push(newItem)
          }
        }
      },
      loadData (data) {
        if (!data) {
          data = this.data
        } else {
          this.data.length = 0
          var self = this
          _.forEach(data, function (item) { self.data.push(item) })
        }
        if (this.dataIsFlat) {
          // If sort field is defined, sedn sorted data
          if (this.orderFieldName !== '') {
            // this.initializeFlatData(_.orderBy(data, this.orderFieldName, 'asc'))
            this.initializeFlatData(_.orderBy(data, [ (o) => { return o[this.orderFieldName] || '' } ], 'asc'))
          } else {
            this.initializeFlatData(data)
          }
        } else {
          this.initializeData(data)
        }
      }
    },

    mounted () {
      this.itemDraggable = this.draggable
      if (typeof this.settings !== 'undefined' && this.settings !== {}) {
        this.initializeSettings(this.settings)
      }

      this.loadData()

      if (this.async) {
        this.$set(this.data, 0, this.initializeLoading())
        this.handleAsyncLoad(this.data, this)
      }
    },
    components: {
      TreeItem
    },
    watch: {
      data () {
        if (this.loadDataOnWatch) {
          this.loadData()
        }
        this.loadDataOnWatch = true
      }
    }
  }
</script>
<style lang="less">
    @import "./less/style";
</style>